---
title: Nginx安装部署
date: 2026-01-27 00:00:00 +0800
categories: [web服务器,nginx]
tags: [url rewrite]
---
**一、URL重写介绍**

Rewrite是Nginx提供的一个重要功能，几乎是所有web产品必备技能，用于实现URL重写。

Nginx的rewrite功能主要用来实现URL的重定向，需要PCRE软件支持，即通过perl兼容正则表达式进行规则匹配。默认参数编译nginx就会支持rewrite的模块，但是也必须要PCRE的支持。


**二、应用场景**

域名变更

用户跳转

伪静态场景

**三、URL重写原理**

URL重写的本质，是在HTTP请求处理过程中，修改请求URI，然后让请求继续按新的URI走后续处理流程或直接返回重定向响应。

它不修改浏览器发出的请求，而是Nginx在内部接管并重写请求路径。它发生在Nginx内部，在请求还没有转发给后端之前。


**四、URL模块语法**

4.1、set 设置变量

```
set $variable value;
```

例子：
```
        location / {
            root   html;
            index  index.html index.htm;

            # 将http://192.168.88.128重写为http://192.168.88.128
            set $name haha;
            rewrite ^(.*)$ http://192.168.88.128/$name;
        }
```

在以上配置中，对http://192.168.88.128的任意路径发起的请求都会被匹配，并302重定向。


4.2、if 条件判断

if语法
```
if (condition) { ... }
```

条件判断符

字符串比较
```
= 等于 变量值与字符串完全一致，如if ($request_method = POST) { ... }
!= 不等于 变量值与字符串不一致，如if ($remote_addr != 192.168.1.1) { ... }
```

正则表达式匹配

```
~ 区分大小写匹配，如if ($uri ~ "\.php$")
!~ 区分大小写不匹配
~* 不区分大小的匹配
!~* 不区分大小写不匹配，如 if ($uri !~* "\.html$")
```

例子
```
        location / {
            root   html;
            index  index.html index.htm;

            # 如果客户端浏览器是chrome，返回403
            if ($http_user_agent ~* 'Chrome'){
                return 403;
            }
        }
```



4.3、return 定义返回数据

语法
```
return code URL
return URL
return code TEXT
return code
```

例子：
```
        location / {
            root   html;
            index  index.html index.htm;

            # 如果客户端浏览器是chrome，返回403
            if ($http_user_agent ~* 'Chrome'){
                return 403;
            }
        }
```


4.4、break 停止执行当前虚拟主机的后续rewrite指令集

例子：
```
        location / {
            root   html;
            index  index.html index.htm;

            # 如果客户端浏览器是chrome，返回403
            if ($http_user_agent ~* 'Chrome'){
                    break;
                    return 403;
            }
        }
```

在rewrite模块，break表示停止执行当前块中后续的所有指令，比如这个if块，当Nginx执行到break，它会直接跳过后面的return 403，继续处理location块剩下的部分，因此chrome浏览器可以正常访问，不会收到403错误。



4.5、rewrite 实现重写url

语法
```
# 关键字 正则表达式 替换内容 标记
rewrite <regex> <replacement> [flag];
```



flag：
- last   本条规则匹配后，继续向下匹配新的location URI规则
- break  本条规则匹配完成即终止，不再匹配后面任何规则
- redirect   返回302临时重定向，浏览器地址会显示跳转后的URL地址
- permanent   返回301永久重定向，浏览器地址栏会显示跳转后的URL地址


permanent永久重定向实现域名跳转
```
        location / {
            root   html;
            index  index.html index.htm;

            rewrite ^/$ https://www.baidu.com permanent;

        }
```

我使用虚拟机搭建的nginx，server_name是localhost而不是域名，访问虚拟机ip即可发现页面跳转到百度。


redirect临时重定向域名跳转

```
        location / {
            root   html;
            index  index.html index.htm;

            rewrite ^/$ https://www.baidu.com redirect;

        }
```

重定向就是将网页自动转向重定向，permanent和redirect重定向的区别：

301永久重定向：新网址完全继承旧网址，旧网址的排名完全清零

301重定向是网页更改地址后对搜索引擎最友好的方法，只要不是暂时搬移的情况，都建议使用301做转址

302临时重定向：对旧网址没有影响，但新网址不会有排名

搜索引擎会抓取新的内容而保留旧的网址


break标志：类似临时重定向

```
#域名跳转
        location / {
            root   html;
            index  index.html index.htm;

            rewrite ^/$ https://www.baidu.com break;

        }
```



last标志

作用：立刻停止处理当前的rewrite模块指令，并带着重写后的新的URL重新发起一轮匹配。

示例：
```
location /old_path {
    rewrite ^/old_path/(.*)$ /new_path/$1 last;
    # 这里的指令永远不会被执行
    add_header X-Status "Finished"; 
}

location /new_path {
    # 上面的 rewrite 触发后，请求会重新跳到这里进行匹配
    proxy_pass http://backend;
}
```


rewirte指令本质上是在改写字符串，拿上面的配置文件内容为例子，Nginx不关心重写后的路径在磁盘上是否真的存在这样一个文件或文件夹，它只关心重写后的路径下一步该去哪里。

重写路径后的三种常见去向：
1. 指向另一个location，最常见。新路径不需要是真实文件，它可以只是一个逻辑上的”标签“，用来触发另一个location块。
	-  场景：伪静态。你访问 `/article/123`，Nginx 把它重写为 `/api/get_article?id=123`。
	- 实际情况：这里的 `/api/get_article` 可能只是后端程序（如 PHP 或 Node.js）的一个路由接口，服务器磁盘上并没有这个文件夹。

2. 指向代理后端（反向代理）。重写后的路径往往是给后端服务器看的。
	 - 场景：你把 `/google/search` 重写为 `/search`。
	 - 实际情况：Nginx 随后通过 `proxy_pass` 把 `/search` 发给了后端的 Tomcat 或 Python 服务。只要后端程序能处理这个路径，它在 Nginx 的磁盘上存不存在无所谓。

3. 指向静态文件（静态资源）。新路径也可以指向真实存在的文件。
	  -  场景：你把所有对 `.jpg` 的请求重写到 `/images/default.png`。
	  - 实际情况： 这种情况下，`default.png` 必须真实存在于你的服务器磁盘中，否则 Nginx 在匹配完新的 `location` 后，最终会返回 **404 Not Found**。


**`rewrite` 只管“变魔术”，不管“变出来的东西能不能吃”。**

- 如果你重写后的路径是为了匹配另一个 `location` 或转发给后端，它就**不需要**真实存在。
    
- 如果你重写后的路径是希望 Nginx 直接从硬盘读取文件返回给用户，它就**必须**真实存在。



当Nginx遇到last标志时，会发生两件事：
- 停止：不再执行当前server或location块中剩余的rewrite指令。
- 重跳：拿着修改后的新URL，回到整个server块的最开始，重新寻找可以匹配的location。


last会触发重新匹配的过程，所以会比break稍微多一点性能开销。

**死循环风险**：注意！！！如果你的重写逻辑不够好，导致重写后的URL又触发了带last的重写，Nginx最后会因为循环次数过多（默认10次）返回500错误。



**正则表达式**

```
#^ 以什么开头 ^a           
#$ 以什么结尾 c$           
#. 除了回车以外的任意一个字符           
#* 前面的字符可以出现多次或者不出现           
#更多内容看正则表达式 re
```


