**一、默认网站配置**

```
    server {
        listen       80;
        server_name  localhost;

        location / {
            root   html;
            index  index.html index.htm;
        }

        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }

    }
```


**二、目录浏览**

针对某个目录开启目录浏览，这是生产环境常用方法
```
location / {
    root   html;
    index  index.html index.htm;
}

location /files/ {
    root /data;
    #开启目录浏览
    autoindex on;
    autoindex_exact_size off;
    autoindex_localtime on;
    charset utf-8;
}

```

目录结构
`/data/files`

访问
`http://IP/files/`

这样配置保证首页正常，下载目录可浏览，保证其他文件安全。

**不要在网站根目录开启目录浏览，不然根目录的所有文件都可以被访问和下载！！！！autoindex只能用在功能性目录，比如软件包下载站，镜像源，日志归档，以及文件共享等地方。**

另外补充：开启目录浏览，不要在前面设置index，如果目录里面存在首页文件比如index.html等，Nginx就会优先返回首页，而不会显示目录列表。autoindex只有在没有index文件时才有效。

如果设置了index，又想开启目录浏览(这部分只需要了解)：
```
location / {
    root html;
    index off;
    autoindex on;
}
```


效果如下图
![[Pasted image 20260127201145.png]]

**三、访问控制**

```
    server {
        listen       80;
        server_name  localhost;

        location / {
            root   html;
            index  index.html index.htm;
        }

        location /a/ {
            autoindex on;
            allow 192.168.88.0/24;
            deny all;
        }
```

192.168.88.x的主机都可以访问，其他的不行
![[Pasted image 20260127214524.png]]

**四、登录认证**

4.1、安装生成密码的工具

Ubuntu/Debian
```
apt install apache2-utils -y

```

centos/alma/rocky
```
yum install httpd-tools -y
```

4.2、创建账号密码文件
```
mkdir -p /etc/nginx/auth
htpasswd -c /etc/nginx/auth/a.passwd admin
```
输入密码即可。

4.3、 在Nginx开启 HTTP basic 认证
```
location /a/ {
    autoindex on;

    auth_basic "登录认证";
    auth_basic_user_file /etc/nginx/auth/a.passwd;
}
```

访问/a/，浏览器弹出用户名和密码框，输入正确才能访问

**认证+ IP白名单配置(进阶)**
```
location /a/ {
    autoindex on;
    
	#在多个访问控制条件里，满足任意一个就放行
	# 对应的有 satisfy all;  必须满足全部条件才放行
	
	# 只需要IP允许或者 账号密码正确就可以访问/a/
    satisfy any;

    allow 192.168.88.0/24;
    deny all;

    auth_basic "Auth Required";
    auth_basic_user_file /etc/nginx/auth/a.passwd;
}

```

内网免登录，外网需要账号密码。

另外，http basic认证需要配合https使用，不然抓包会被看到账号密码。
```
listen 443 ssl;
```

**五、日志管理**

nginx访问日志主要由两个参数控制：access_log和log_format。

开启访问日志

main是在前面log_format定义的名字
```
access_log /var/log/nginx/access.log main;
```

关闭访问日志
```
access_log off;
```

日志内容格式——log_format
定义日志里每一列是什么


**日志格式变量**

| 变量                        | 含义     |
| ------------------------- | ------ |
| `$remote_addr`            | 客户端 IP |
| `$remote_user`            | 认证用户   |
| `$time_local`             | 本地时间   |
| `$request`                | 请求行    |
| `$status`                 | 状态码    |
| `$request_time`           | 请求耗时   |
| `$upstream_addr`          | 后端地址   |
| `$upstream_response_time` | 后端耗时   |
| `$http_user_agent`        | 浏览器    |
|                           |        |

错误日志error_log
```
error_log /var/log/nginx/error.log warn;
```

日志级别：
```
debug | info | notice | warn | error | crit
```

减少日志量
```
map $status $loggable {
    ~^[23]  0;
    default 1;
}

access_log /var/log/nginx/access.log main if=$loggable;

```

map比if语句好，if语句适合学习的时候用。

效果：2xx / 3xx不记录，4xx / 5xx才记录，大幅减少日志量。


**完整配置**
```
# 定义一种叫main的日志格式，内容是这一整串变量的拼接
log_format main
'$remote_addr - $remote_user [$time_local] '
'"$request" $status $request_time '
'$body_bytes_sent '
'"$http_referer" "$http_user_agent" '
'$upstream_addr $upstream_response_time';

access_log /var/log/nginx/access.log main buffer=64k flush=5s;
error_log  /var/log/nginx/error.log warn;
```

buffer和flush是性能相关参数，按上面的配置，含义为：日志先写内存，每5秒或满64k才落盘，这样可以减少IO，提升性能。


**日志分割(Log Rotation)**

含义：把不断变大的日志文件，按时间和大小分割成多个小文件，并对旧日志进行压缩 / 保留 / 清理。

作用：日志分割是为了防止日志文件无限增长导致磁盘耗尽，同时提升日志可读性和运维可维护性。  

Nginx 本身不支持自动分割，一般通过 logrotate 按时间或大小切割，并通过 USR1 信号通知 Nginx 重新打开日志文件。

日志分割策略

| 方式  | 示例                  |
| --- | ------------------- |
| 按天  | access.log-20260127 |
| 按大小 | 超过 100MB 就切         |
| 按数量 | 保留最近 7 个            |
| 混合  | 按天 + 保留 14 天        |

**怎么做日志分割**

nginx本身不会自动分割日志，必须靠外部工具，推荐logrotate，它是Linux自带的日志管理工具，但是这里不多做拓展。

手动日志分割
```
# 重命名日志文件（切割）
mv access.log access.log.0
# 通知Nginx重新打开日志文件（USR1信号）
killall -USR1 nginx
# 等待1秒，等待Nginx重新打开日志文件，避免文件句柄未释放就压缩
sleep 1
# 压缩旧日志
gzip access.log.0
```

USR1是Linux信号——SIGUSR1,在Nginx被定义为reopen logs（重新打开日志文件），所以使用kill或者killall命令对nginx发送这个信号，可以触发日志切割。

总之：手动日志分割的核心不是 mv，而是向 Nginx master 进程发送 USR1 信号，让其重新打开日志文件句柄，从而实现日志切换。

日志分割脚本
```
#!/bin/bash

LOG_DIR=/var/log/nginx
PID_FILE=/usr/local/nginx/logs/nginx.pid

mv $LOG_DIR/access.log $LOG_DIR/access.log.$(date +%F)
kill -USR1 `cat $PID_FILE`
sleep 1
gzip $LOG_DIR/access.log.$(date +%F)

```

**六、防盗链**

介绍：只允许自己的网站页面引用资源，禁止别人直接用你的图片 / 视频 / 下载链接。

本质：检查请求的referer头。

Nginx 防盗链通常通过 `valid_referers` 指令校验 HTTP Referer，只允许本站或白名单域名访问资源，非法请求返回 403 或替换图片。这种方式只能防普通盗链，Referer 可被伪造，适合静态资源保护。

白名单域名防盗链

```
location ~* \.(jpg|png|gif)$ {
    valid_referers none blocked *.xxx.com;

    if ($invalid_referer) {
        return 403;
    }
    access_log off;
    expires 30d;
}

```

只允许Referer来自*.xxx.com或无Referer的请求访问静态资源，其他来源一律返回403，并且允许缓存30天