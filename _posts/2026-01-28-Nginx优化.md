
**1、并发优化**

Nginx工作模式：主进程（master） + 工作进程（worker）。

Nginx 使用多进程 + 单线程 + epoll（事件驱动），避免锁竞争，提升并发稳定性。

worker数量定义
```
# 由这台机子的CPU核心数决定，自动识别CPU核心数，避免手动配置
worker_processes auto;
```

CPU亲和性绑定

假设我启用4个工作进程
```
# 将每个 worker 绑定到指定 CPU 核心（CPU 亲和性）
# 掩码方式：1 表示使用该核，0 表示不使用
worker_cpu_affinity 0001 0010 0100 1000;
```

| Worker   | 掩码   | 绑定 CPU |
| -------- | ---- | ------ |
| worker 1 | 0001 | CPU0   |
| worker 2 | 0010 | CPU1   |
| worker 3 | 0100 | CPU2   |
| worker 4 | 1000 | CPU3   |
CPU亲和性绑定可以减少进程在CPU之间迁移，在高负载 + 高并发时更稳定，适用于物理机、CPU密集和高并发场景，云环境和容器不建议使用。



```
worker_processes auto;

# 每个worker最多打开20000个文件描述符（fd）
worker_rlimit_nofile 20000;

events {
    use epoll;             # Linux 高并发必选
    worker_connections 1024;      # 单个worker允许的最大并发连接数，这里在本地虚拟机设置的比较少，实际情况比这大得多
    multi_accept on;       # 提高高并发接入能力
}

```

worker_connections 不是越大越好，盲目调大会导致雪崩。

`worker_rlimit_nofile` 用于提升 Nginx worker 进程可打开的最大文件描述符数量，是高并发场景下防止“Too many open files”的关键参数。

**2、长连接**

减少服务器维护因为与客户端建立http连接产生的大量tcp三次握手四次挥手的开销。本质是让有用的连接留下，没用的尽快走。

前端长链接

必配置参数

```
http {
    keepalive_timeout 60s;        # 长连接空闲时间
    keepalive_requests 8192;    # 单连接最大请求数
}

```

`keepalive_timeout`设置太小，会导致频繁断联，浪费TCP；太大，会导致fd被占满（一个连接就是一个fd），60s比较合适。

`keepalive_requests`可以避免不必要的连接长时间存在。



**3、压缩**

降低传输时间，增加用户体验，降低公司带宽费用。

推荐gzip压缩，有兴趣可以了解一下Brotli。

gzip_proxied——nginx反向代理参数


    #Nginx做为反向代理的时候启用：
    off – 关闭所有的代理结果数据压缩
    expired – 如果header中包含”Expires”头信息，启用压缩
    no-cache – 如果header中包含”Cache-Control:no-cache”头信息，启用压缩
    no-store – 如果header中包含”Cache-Control:no-store”头信息，启用压缩
    private – 如果header中包含”Cache-Control:private”头信息，启用压缩
    no_last_modified – 启用压缩，如果header中包含”Last_Modified”头信息，启用压缩
    no_etag – 启用压缩，如果header中包含“ETag”头信息，启用压缩
    auth – 启用压缩，如果header中包含“Authorization”头信息，启用压缩
    any – 无条件压缩所有结果数据


```
http {

    # =========================
    # Gzip 压缩核心配置
    # =========================

    gzip on;                            # 开启 gzip

    gzip_disable "MSIE [1-6]\.";        # 禁用极老 IE的gzip

    # =========================
    # 压缩策略（省 CPU + 省带宽）
    # =========================

    gzip_min_length 1k;                 # 小于 1KB 不压缩
    gzip_comp_level 5;                  # 压缩等级 1–9（5 是生产最优解，9压缩率更高，但对CPU负担大）

    gzip_vary on;                       # 添加 Vary: Accept-Encoding，CDN / 代理正确缓存压缩内容，是否在http header中添加Vary: Accept-Encoding，建议开启

    gzip_proxied any;                   # Nginx 作为反向代理时，对所有代理响应启用压缩

    # =========================
    # 缓冲与协议
    # =========================

    gzip_buffers 16 8k;                 # 设置压缩缓冲区大小（并发友好）
    gzip_http_version 1.1;              # 设置gzip压缩针对的http协议版本

    # =========================
    # 只压缩值得压缩的文件类型
    # =========================

    gzip_types
        text/plain
        text/css
        application/json
        application/javascript
        application/xml
        text/xml
        image/svg+xml
        application/rss+xml;

    # 刻意不压缩的文件：
    # jpg / png / gif / mp4 / zip / pdf
    # 因为它们已经是压缩格式
}

```

**4、静态缓存**

将部分数据缓存在用户本地磁盘，用户加载时，如果本地和服务器的数据一致，则从本地加载。提升用户访问速度，提升体验度，节省公司带宽成本。

```
# ===============================
# 静态资源：强缓存（本地磁盘）
# ===============================
location ~* \.(js|css|png|jpg|jpeg|gif|svg|woff|woff2|ttf|ico)$ {

    expires 30d;                               # 本地缓存 30 天
    add_header Cache-Control "public";         # 允许浏览器和 CDN 缓存

    access_log off;                            # 关闭日志，减少 IO
}

```

效果：
- 浏览器30天不访问服务器
- 页面秒开
- 带宽消耗有效下降


加强版配置

版本号 + 永久缓存

1、静态资源使用版本号
```
app.8f3a9c.js
style.a92f.css
```

2、配合Nginx永久缓存
```
location ~* \.(js|css|svg|woff2)$ {
    expires 365d;
    
    # immutable含义：这个资源一旦缓存，就一年不会变
    add_header Cache-Control "public, immutable";
}
```

效果：
- 文件名不变，永久不请求服务器
- 文件名修改，强制刷新
- 带宽消耗减少


gzip + 静态缓存示例

```
http {

    gzip on;
    gzip_comp_level 5;
    gzip_min_length 1k;
    gzip_types text/css application/javascript application/json;

    server {
        listen 80;

        # 静态资源强缓存
        location ~* \.(js|css|png|jpg|svg|woff2)$ {
            expires 30d;
            add_header Cache-Control "public";
            access_log off;
        }

        # HTML页面短缓存，防止用户看到旧页面
        # 另外，expires和no-cache不要同时乱配置，浏览器会出现不可预测的情况
        location / {
            expires 5m;
            # 像登录这种用户页面，就不能做public缓存，不然会导致信息泄露
            add_header Cache-Control "private";
        }

        # 不要缓存接口
        location /api/ {
            add_header Cache-Control "no-store";
        }
    }
}

```

