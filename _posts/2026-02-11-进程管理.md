
**一、进程介绍**

进程是一个程序正在运行的实例。之所以创建进程，就是为了让多个程序可以并发的执行，从而提高系统的资源利用率和吞吐量。也可以说，进程就是一个程序的执行活动。


**进程和程序的区别：**

- 程序是一个静态的指令集合。
- 而进程是一个程序的动态执行过程，它具有生命周期，是动态产生，动态消亡的。
- 进程是一个申请系统资源、独立运行的单位，因此它使用系统的运行资源；而程序不能申请系统资源、不能被系统调度、也不能作为独立运行的单位，因此，程序不占用系统的运行资源。
- 一个程序在运行过程可以产生多个进程；一个进程在生命周期内可以顺序执行若干个程序。


**进程属性**

在Linux系统总是有很多进程同时运行，每一个程序都有一个识别号，叫作PID，用来区别不同的进程。

进程之间是有关联性的，有的进程会衍生出额外的进程，这时，这组进程就存在了父子关系，衍生出来的进程为子进程，原本的进程叫父进程。



**二、Linux任务**

由于Linux是一个多人多任务的操作系统，所以用户在使用Linux时有时候一些工作需要我们紧盯着完成的进度，有些工作我们直接放后台执行就可以了。这里涉及到任务的前后台执行问题。

开启一个在后台执行的工作
```
# &表示后台执行
touch 1.txt &


➜  ~ echo hh > 1.txt
➜  ~ cat 1.txt &      
[1] 1144
hh                                                          # 执行完成后，在下一次回车时会有一个反馈                    
[1]  + 1144 done       cat 1.txt
```


将当前工作调到后台
```
vim 1.txt

# ctrl + z调到后台



➜  ~ vim 1.txt   
# ctrl + z将任务挂到后台后，工作状态为暂停
[1]  + 1169 suspended  vim 1.txt
➜  ~ 
```


后台工作的查看
```
# 查看后台工作
jobs

# 查看进程工作，并显示进程号

# 只看状态停止的后台工作
jobs -s

# 只看状态为运行的后台工作
jobs -r
```

jobs任务状态：

+：最近一个被调到后台的任务，如果直接输入fg命令不带参数，shell会默认把带有`+`的任务调到前台。为当前默认任务。

-：倒数第二个被操作的任务，一旦带有`+`的任务结束，这个带有`-`的任务自动晋升为新的`+`。为备选任务。

如果你的后台任务超过两个，剩下的任务前面没有任何符号。它们必须排队，直到前面的`+`和`-`任务完成。

```
# fg命令可以将后台任务调到前台
# fg %工作序号（%可省略）

# 调回当前任务，等同于fg
fg %+

# 调回备选任务
fg %-

# 根据任务序号，即jobs命令里任务中括号的数字杀死进程，如果加上-9 代表强制结束不管其状态
kill %1
```

bg

bg命令用法与fg类似，它的作用是调用任务在后台运行。

如果你ctrl + z停止了某项任务，想重新在后台运行，jobs查看任务序列号，使用bg命令，该任务会立刻从`Stopped`变成`Running`，在后台继续运行。

```
# 默认让带有`+`的任务在后台运行
bg

# 指定编号为n的任务在后台运行
bg %2
```

fg与bg区别：
- fg把任务抓回前台，你会重新看到它的输出，并无法输入其他命令。
- bg让任务在后台运行。

另外，bg运行的任务，在你断开ssh连接或关闭终端时会被系统杀掉。想让它继续跑，使用nohup、screen、tmux等命令。


nohup用法
```
nohup ./test.sh &
```

默认情况下，nohup会把程序的日志自动输出到当前目录下的nohup.out文件。如果想自定义日志位置：
```
nohup ./test.sh > test.log 2>&1 &
```

总之，Linux的任务可以提高fg、bg、kill、jobs等命令来处理。



**三、进程的查看与管理**

查看当前终端进程
```
ps
```


查看所有进程
```
# 显示uid、pid、ppid、c、stime、tty、time(占用cpu时间)、cmd(启动命令)
ps -ef

# 显示user、pid、%cpu、%mem、VSZ虚拟内存、RSS实际物理内存、tty、、stat进程状态、start启动时间、time、command命令
ps aux
```

```
UID 用户识别号
PID 进程识别号
PPID    父进程号
C       cpu使用率 %
TTY     由哪个终端开启的    pts/n=图形界面或远程       ttyn=字符界面       ?=系统进程
TIME    用掉的CPU时间
CMD     执行的命令
```

进程状态STAT
```
R 运行
S 睡眠（可中断）
D 不可中断睡眠（IO）
T 停止
Z 僵尸进程
```

D状态的进程kill不掉，因为它在等待IO，内核态阻塞。


ps -eo自定义输出
```
ps -eo pid,ppid,user,%cpu,%mem,cmd
```

-e，所有进程
-o，指定输出格式


按cpu降序排列
```
ps -eo pid,user,%cpu,%mem,cmd --sort=-%cpu
```

按内存降序排列
```
ps -eo pid,%cpu,%mem,cmd --sort=-%cpu,-%mem
```


查看内存占用前10
```
ps aux --sort=-%mem | head
```

查看CPU占用前10
```
ps aux --sort=-%cpu | head
```


只看某个用户
```
ps -u root
```

查看某个进程
```
ps -p 1234
```
多个进程：
```
ps -p 1,2,3
```


查看进程树
```
ps -ef --forest
```

查找僵尸进程的父子关系：
```
ps -ef | grep Z
```
看ppid即可


查看线程
```
ps -eLf
```
LWP是线程ID，NLWP是线程数量。

统计进程数量
```
ps aux | wc -l
```

查看某进程打开的线程数
```
ps -eLf | grep pid
```

查看当前用户启动的进程
```
ps -l
```


ps本质是通过读取/proc获得进程信息。

ps显示的是运行它那一刻的静态的内容，top是动态的。


**top动态查看进程**

```
top

# 每隔一秒刷新
top -d 1
```


**pstree查看进程间关系**

```
pstree
```

如果没有需要安装：
```
sudo apt install psmisc
```


带pid显示
```
pstree -p
```
![](/assets/img/Pasted image 20260212020440.png)

查看某个进程的子进程
```
# 语法：
pstree -p pid

# 查看systemd启动的所有进程
pstree -p 1
```

`ps -ef --forest`或`pstree -p`都可以查看进程的父子关系。进程之间通过ppid建立层级结构。


**killall和pkill命令**

killall根据进程名杀死进程，而不是pid。

```
killall nginx

# 等同于 pkill nginx
```

```
强制杀死进程
killall -9 nginx
```


pkill可以根据名字、用户、条件杀死进程。

```
pkill nginx

# 指定信号
pkill -9 nginx

# 杀test用户所有进程
pkill -u test

# 按照完整命令匹配
pkill -f "python3 app.py"
```


**pgrep查找pid**

```
pgrep nginx
```


根据端口杀掉进程：
```
lsof -i :8080
kill pid
```



**四、进程优先级**

```
# 查看PRI和NI
ps -l
```
进程通过PRI和NI控制进程的优先级。优先级决定CPU先处理谁的数据。


Linux每个程序都有优先级，也就是PRI，它的值越小优先级越高。PRI值由内核控制用户不能修改。

用户想控制程序的优先级只能调整NI的值，也就是nice值。

普通用户只能设置nice值0~19的范围，root用户可以设置-20~19。


```
# 给命令设置最高优先级。注意，普通用户不能设置复制！！！
nice -n -20 vim t.txt &
```


修改正在运行的进程优先级
```
# 修改pid为1234的进程nice值为10
renice 10 -p 1234
# 按照用户设置nice值
renice 10 -u test
```


**PRI和NI的关系**

PRI = 20 + NI


NI越小，PRI越小，优先级越高


